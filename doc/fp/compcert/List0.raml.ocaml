
let rec leqNat x y =
  match y with
  | 0 -> True
  | S(y') -> (match x with
            | S(x') -> leqNat x' y'
            | 0 -> False)
;;
let rec eqNat x y =
  match y with
  | 0 -> (match x with
      | 0 -> True
      | S(x') -> False)
  | S(y') -> (match x with
            | S(x') -> eqNat x' y'
            | 0 -> False)
;;
let rec geqNat x y =
  match x with
   | 0 -> False
   | S(x') -> (match y with
              | 0 -> True
              | S(y') -> geqNat x' y')
;;
let rec ltNat x y =
  match y with
   | 0 -> False
   | S(y') -> (match x with
        | 0 -> True
        | S(x') -> ltNat x' y')
;;
let rec gtNat x y =
  match x with
   | 0 -> False
   | S(x') -> (match y with
             | 0 -> True
             | S(y') -> gtNat x' y')


;;
let ifz n th el = match n with
   | 0 -> th 0
   | S(x) -> el x
;;
let ite b th el = match b with
   | True()-> th
   | False()-> el
;;
let minus n m =
  let rec minus' m n = match m with
        | 0 -> 0
        | S(x) -> (match n with
          | 0 -> m
          | S(y) -> minus' x y)
  in Pair(minus' n m,m)
;;
let rec plus n m = match m with
  | 0 -> n
  | S(x) -> S(plus n x)
;;
type ('a,'b,'c) triple = Triple of 'a * 'b * 'c
;;
let rec div_mod n m = match (minus n m) with
  | Pair(res,m) -> (match res with
                   | 0 -> Triple (0,n,m)
                   | S(x) -> (match (div_mod res m) with
                             | Triple(a,rest,unusedM) -> Triple(plus S(0) a,rest,m)))
;;
let rec mult n m = match n with
   | 0 -> 0
   | S(x) -> S(plus (mult x m) m)
;;
type 'a list = Nil | Cons of 'a * 'a list
;;
type Unit = Unit
;;
type ('a,'b) pair = Pair of 'a * 'b

(*-- Datatypes.ml --*)
(** val implb : bool -> bool -> bool **)
;;
let implb b1 b2 =
  ite (b1 (b2 (true)))

(** val xorb : bool -> bool -> bool **)
;;
let xorb b1 b2 =
  ite (b1 (if b2 then false (true else b2)))

(** val negb : bool -> bool **)
;;
let negb xyz = match xyz with x ->
ite ((x = true) (false (true)))
;;
type nat = O
| S(of) nat
;;
type ('a, 'b) sum =
| Coq_inl(of) 'a
| Coq_inr(of) 'b

(** val fst : ('a1 * 'a2) -> 'a1 **)
;;
let fst xyz = match xyz with a ->
let (x, y) = a in x

(** val snd : ('a1 * 'a2) -> 'a2 **)
;;
let snd xyz = match xyz with a ->
let (x, y) = a in y

(** val length : 'a1 list -> nat **)
;;
let rec length xyz = match xyz with myvariable ->
match myvariable with
| Nil()-> O
| Cons(y,l') -> S (length l')

(** val app : 'a1 list -> 'a1 list -> 'a1 list **)
;;
let rec app l m =
  match l with
  | Nil()-> m
  | Cons(a,l1) -> Cons(a,(app l1 m))
;;
type comparison = Eq
| Lt
| Gt

(** val coq_CompOpp : comparison -> comparison **)
;;
let coq_CompOpp xyz = match xyz with myvariable ->
match myvariable with
| Eq()-> Eq
| Lt()-> Gt
| Gt()-> Lt
;;
type coq_CompareSpecT =
| CompEqT
| CompLtT
| CompGtT

(** val coq_CompareSpec2Type : comparison -> coq_CompareSpecT **)
;;
let coq_CompareSpec2Type xyz = match xyz with myvariable ->
match myvariable with
| Eq()-> CompEqT
| Lt()-> CompLtT
| Gt()-> CompGtT
;;
type 'a coq_CompSpecT = coq_CompareSpecT

(** val coq_CompSpec2Type : 'a1 -> 'a1 -> comparison -> 'a1 coq_CompSpecT **)
;;
let coq_CompSpec2Type x y c =
  coq_CompareSpec2Type c

(*$$ Datatypes.ml $$*)
(*-- Specif.ml --*)
type 'a coq_sig =
  'a
  (* singleton inductive, whose constructor was exist *)
;;
type 'a sig2 =
  'a
  (* singleton inductive, whose constructor was exist2 *)
;;
type ('a, 'p) sigT =
| Coq_existT(of) 'a * 'p

(** val projT1 : ('a1, 'a2) sigT -> 'a1 **)
;;
let projT1 xyz = match xyz with x ->
match x with
| Coq_existT()(a, p) -> a

(** val projT2 : ('a1, 'a2) sigT -> 'a2 **)
;;
let projT2 xyz = match xyz with x ->
match x with
| Coq_existT()(x0, h) -> h
;;
type 'a coq_Exc = 'a option

(** val value : 'a1 -> 'a1 option **)
;;
let value x =
  Some x

(** val error : 'a1 option **)
;;
let error =
  None

(*$$ Specif.ml $$*)

(** val hd : 'a1 -> 'a1 list -> 'a1 **)
;;
let hd default xyz = match xyz with myvariable ->
match myvariable with
| Nil()-> default
| Cons(x,l0) -> x

(** val tl : 'a1 list -> 'a1 list **)
;;
let tl xyz = match xyz with myvariable ->
match myvariable with
| Nil()-> Nil
| Cons(a,m) -> m

(** val in_dec : ('a1 -> 'a1 -> bool) -> 'a1 -> 'a1 list -> bool **)
;;
let rec in_dec h a xyz = match xyz with myvariable ->
match myvariable with
| Nil()-> false
| Cons(y,l0) -> let s = h y a in ite (s (true (in_dec h a l0)))

(** val nth_error : 'a1 list -> nat -> 'a1 coq_Exc **)
;;
let rec nth_error l xyz = match xyz with myvariable ->
match myvariable with
| O()->
  (match l with
   | Nil()-> error
   | Cons(x,l0) -> value x)
| S(n)0 ->
  (match l with
   | Nil()-> error
   | Cons(a,l0) -> nth_error l0 n0)

(** val remove : ('a1 -> 'a1 -> bool) -> 'a1 -> 'a1 list -> 'a1 list **)
;;
let rec remove eq_dec x xyz = match xyz with myvariable ->
match myvariable with
| Nil()-> Nil
| Cons(y,tl0) ->
  ite (eq_dec x y (remove eq_dec x tl0 (Cons(y,(remove eq_dec x tl0)))))

(** val rev : 'a1 list -> 'a1 list **)
;;
let rec rev xyz = match xyz with myvariable ->
match myvariable with
| Nil()-> Nil
| Cons(x,l') -> app (rev l') (x :: Nil)

(** val rev_append : 'a1 list -> 'a1 list -> 'a1 list **)
;;
let rec rev_append l l' =
  match l with
  | Nil()-> l'
  | Cons(a,l0) -> rev_append l0 (Cons(a,l'))

(** val rev' : 'a1 list -> 'a1 list **)
;;
let rev' l =
  rev_append l Nil

(** val list_eq_dec :
    ('a1 -> 'a1 -> bool) -> 'a1 list -> 'a1 list -> bool **)
;;
let rec list_eq_dec eq_dec l l' =
  match l with
  | Nil()->
    (match l' with
     | Nil()-> true
     | Cons(a,l0) -> false)
  | Cons(y,l0) ->
    (match l' with
     | Nil()-> false
     | Cons(a0,l1) -> ite (eq_dec y a0 (list_eq_dec eq_dec l0 l1 (false))))

(** val map : ('a1 -> 'a2) -> 'a1 list -> 'a2 list **)
;;
let rec map f xyz = match xyz with myvariable ->
match myvariable with
| Nil()-> Nil
| (Cons(a,Cons(t) -> (f a,(map f t))))

(** val fold_left : ('a1 -> 'a2 -> 'a1) -> 'a2 list -> 'a1 -> 'a1 **)
;;
let rec fold_left f l a0 =
  match l with
  | Nil()-> a0
  | Cons(b,t) -> fold_left f t (f a0 b)

(** val fold_right : ('a2 -> 'a1 -> 'a1) -> 'a1 -> 'a2 list -> 'a1 **)
;;
let rec fold_right f a0 xyz = match xyz with myvariable ->
match myvariable with
| Nil()-> a0
| Cons(b,t) -> f b (fold_right f a0 t)

(** val existsb : ('a1 -> bool) -> 'a1 list -> bool **)
;;
let rec existsb f xyz = match xyz with myvariable ->
match myvariable with
| Nil()-> false
| Cons(a,l0) -> (||) (f a) (existsb f l0)

(** val forallb : ('a1 -> bool) -> 'a1 list -> bool **)
;;
let rec forallb f xyz = match xyz with myvariable ->
match myvariable with
| Nil()-> true
| Cons(a,l0) -> (&&) (f a) (forallb f l0)

(** val filter : ('a1 -> bool) -> 'a1 list -> 'a1 list **)
;;
let rec filter f xyz = match xyz with myvariable ->
match myvariable with
| Nil()-> Nil
| Cons(x,l0) -> ite (f x (Cons(x,(filter f l0)) (filter f l0)))

 ()
;;
