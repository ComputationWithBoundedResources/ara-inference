
let rec leqNat x y =
  match y with
  | 0 -> True
  | S(y') -> (match x with
            | S(x') -> leqNat x' y'
            | 0 -> False)
;;
let rec eqNat x y =
  match y with
  | 0 -> (match x with
      | 0 -> True
      | S(x') -> False)
  | S(y') -> (match x with
            | S(x') -> eqNat x' y'
            | 0 -> False)
;;
let rec geqNat x y =
  match x with
   | 0 -> False
   | S(x') -> (match y with
              | 0 -> True
              | S(y') -> geqNat x' y')
;;
let rec ltNat x y =
  match y with
   | 0 -> False
   | S(y') -> (match x with
        | 0 -> True
        | S(x') -> ltNat x' y')
;;
let rec gtNat x y =
  match x with
   | 0 -> False
   | S(x') -> (match y with
             | 0 -> True
             | S(y') -> gtNat x' y')


;;
let ifz n th el = match n with
   | 0 -> th 0
   | S(x) -> el x
;;
let ite b th el = match b with
   | True()-> th
   | False()-> el
;;
let minus n m =
  let rec minus' m n = match m with
        | 0 -> 0
        | S(x) -> (match n with
          | 0 -> m
          | S(y) -> minus' x y)
  in Pair(minus' n m,m)
;;
let rec plus n m = match m with
  | 0 -> n
  | S(x) -> S(plus n x)
;;
type ('a,'b,'c) triple = Triple of 'a * 'b * 'c
;;
let rec div_mod n m = match (minus n m) with
  | Pair(res,m) -> (match res with
                   | 0 -> Triple (0,n,m)
                   | S(x) -> (match (div_mod res m) with
                             | Triple(a,rest,unusedM) -> Triple(plus S(0) a,rest,m)))
;;
let rec mult n m = match n with
   | 0 -> 0
   | S(x) -> S(plus (mult x m) m)
;;
type bool = True | False
;;
type 'a option = None | Some of 'a
;;
type 'a list = Nil | Cons of 'a * 'a list
;;
type Unit = Unit
;;
type ('a,'b) pair = Pair of 'a * 'b

(* * * * * * * * * * *
 * Resource Aware ML *
 * * * * * * * * * * *
 *
 * * *  Use Cases  * *
 *
 * File:
 *   examples/constant_time/kmeans.raml
 *
 * Author:
 *   Matt Fredrikson, Jan Hoffmann (S(S(0))016)
 *
 * Description:
 *   K-means algorithm
 *
 *)
;;
let reverse l =
  let rec reverse_aux a l' =
    
    match l' with
    | Nil()-> a
    | Cons(h,t) -> reverse_aux (Cons(h,a)) t
  in reverse_aux Nil l
;;
let map f bag =
  let rec map_aux a bag' =
    
    match bag' with
    | Nil()-> reverse a
    | (Cons(h,Cons(t) -> map_aux ((f h,a)))) t
  in map_aux Nil bag
;;
let sum bag =
  let rec sum_aux a bag' =
    
    match bag' with
    | Nil()-> a
    | Cons(h,t) -> sum_aux (a +. h) t
  in sum_aux 0.0 bag
;;
let size bag =
  let rec size_aux a bag' =
    
    match bag' with
    | Nil()-> a
    | Cons(h,t) -> size_aux (Rnat.succ a) t
  in size_aux Rnat.zero bag
;;
let split pred bag =
  let rec split_aux bag' in_bag out_bag =
    
    match bag' with
    | Nil()-> (in_bag, out_bag)
    | Cons(h,t) ->
      let pred_result = pred h in
      let (new_in, new_out) =
        ite ((pred h) ((Cons(h,in)_bag, out_bag)))
        ((in_bag, Cons(h,out)_bag))
      in
      split_aux t new_in new_out
  in split_aux bag Nil Nil
;;
let rec zip l1 l2 =
  match l1 with
  | Nil()-> Nil
  | Cons(x,xs) ->
    match l2 with
    | Nil()-> let unused = Raml.consume xs in Nil
    | (Cons(y,ys) -> (x,Cons(y,(zip xs ys))))
;;
let avg pi =
  let (p,i) = pi in
  let (x,y) = p in
  (x/.i, y/.i)
;;
let sqdist p1 p2 =
  let (x1,y1) = p1 in
  let (x2,y2) = p2 in
  let dx = x2 -. x1 in
  let dy = y2 -. y1 in
  dx*.dx +. dy*.dy
;;
let argmin l =
  let rec argmin_aux best bestidx curidx x =
    let nextidx = curidx + S(0) in
    match x with
    | Nil()-> bestidx
    | Cons(h,t) ->
      ite (h < best ((argmin_aux h curidx nextidx t)))
      ((argmin_aux best bestidx nextidx t))
  in argmin_aux S(0)0000000.0 0 0 l

;;
let rec map_arg f acc l =
  match l with
  | Nil()-> Nil
  | Cons(x,xs) ->
    (f acc x)Cons(,map)_arg f acc xs
;;
let assign means db =
  let distmapper means pt =
    let sqdists = map (fun pt2 -> sqdist pt pt2) means in
    (pt, argmin sqdists)
  in map_arg distmapper means db

;;
let partition ldb m =

  let rec insert x bags overflow =
      let () = Raml.consume () in
    let (pt,i) = x in
    
    match bags with
    | Nil()-> (Nil, Cons(x,overflow))
    | Cons(y,ys) ->
      let (n,bag) = y in
      ite (n = (i) then)
        let () = Raml.consume ys in
        ((n,(Cons(x,Cons(bag),ys),overflow)))
      else
        let (bags',overflow') = insert x ys overflow in
        ((n,bag)Cons(,bags'), overflow')
  in

  let rec partition ldb bags overflow =
    
    match ldb with
    | Nil()-> (bags, overflow)
    | Cons(x,xs) ->
      let (bags',overflow') = insert x bags overflow in
      partition xs bags' overflow'

  in

  let rec mk_bags m =
    Rnat.ifz m
      (fun () -> Nil)
      (fun m' ->
         let n = Rnat.to_int m' in
         let bags = mk_bags m' in
         (n,Nil)Cons(,bags)
      )
  in

  let bags = mk_bags m in
  let (bags, overflow) = partition ldb bags Nil in
  let bags = (S(0),overflow)Cons(,bags) in
  map (fun (a,b) -> b) bags

(* let rec partition ldb m = *)
(*   Rnat.ifz m *)
(*     (fun () -> Raml.consume ldb; Nil) *)
(*     (fun m' -> *)
(*        let yes, no = split (fun x -> let (pt, i) = x in i = Rnat.to_int m') ldb in *)
(*        Raml.consume(yes,no,m'); *)
(*        Cons(yes,(partition no m')) *)
(*     ) *)
;;
let totx db = sum (map (fun r -> let (x,y)=r in x) db)
let toty db = sum (map (fun r -> let (x,y)=r in y) db)
let tot db = sum (map (fun r -> S(0)) db)
;;
let iterate db means =
  let ldb = assign means db in
  let p = partition ldb (size means) in
  let db2 = map (fun el -> map (fun e -> let (pt, n) = e in pt) el) p in
  let tx = map totx db2 in
  let ty = map toty db2 in
  let t = map tot db2 in
  map avg (zip (zip tx ty) t)
;;
let initmeans x =
  let point1 = (S(0), S(0)) in
  let point2 = (S(S(0)), S(S(0))) in
  let point3 = (S(S(S(0))), S(S(S(0)))) in
  (Cons(point1,Cons( point2,Cons( point3,Nil))))
;;
let main db =
  let means = initmeans () in
  let foo = iterate db means in
  let foo2 = iterate db foo in
  foo2
;;
let ref_db = (Cons((S(0),1),Cons( (S(0).25,1),Cons( (S(S(0)),2.5),Cons( (S(0).75,4),Cons( (S(0)0.0,10.0),Cons( (S(S(S(S(S(S(0)))))).5,15),Nil)))))))
;;
let main = main ref_db

;;
