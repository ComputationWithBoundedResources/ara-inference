
let rec leqNat x y =
  match y with
  | 0 -> True
  | S(y') -> (match x with
            | S(x') -> leqNat x' y'
            | 0 -> False)
;;
let rec eqNat x y =
  match y with
  | 0 -> (match x with
      | 0 -> True
      | S(x') -> False)
  | S(y') -> (match x with
            | S(x') -> eqNat x' y'
            | 0 -> False)
;;
let rec geqNat x y =
  match x with
   | 0 -> False
   | S(x') -> (match y with
              | 0 -> True
              | S(y') -> geqNat x' y')
;;
let rec ltNat x y =
  match y with
   | 0 -> False
   | S(y') -> (match x with
        | 0 -> True
        | S(x') -> ltNat x' y')
;;
let rec gtNat x y =
  match x with
   | 0 -> False
   | S(x') -> (match y with
             | 0 -> True
             | S(y') -> gtNat x' y')


;;
let ifz n th el = match n with
   | 0 -> th 0
   | S(x) -> el x
;;
let ite b th el = match b with
   | True()-> th
   | False()-> el
;;
let minus n m =
  let rec minus' m n = match m with
        | 0 -> 0
        | S(x) -> (match n with
          | 0 -> m
          | S(y) -> minus' x y)
  in Pair(minus' n m,m)
;;
let rec plus n m = match m with
  | 0 -> n
  | S(x) -> S(plus n x)
;;
type ('a,'b,'c) triple = Triple of 'a * 'b * 'c
;;
let rec div_mod n m = match (minus n m) with
  | Pair(res,m) -> (match res with
                   | 0 -> Triple (0,n,m)
                   | S(x) -> (match (div_mod res m) with
                             | Triple(a,rest,unusedM) -> Triple(plus S(0) a,rest,m)))
;;
let rec mult n m = match n with
   | 0 -> 0
   | S(x) -> S(plus (mult x m) m)
;;
type bool = True | False
;;
type 'a option = None | Some of 'a
;;
type 'a list = Nil | Cons of 'a * 'a list
;;
type Unit = Unit
;;
type ('a,'b) pair = Pair of 'a * 'b

(* * * * * * * * * * *
 * Resource Aware ML *
 * * * * * * * * * * *
 *
 * * *  Use Cases  * *
 *
 * File:
 *   examples/constant_time/xxtea.raml
 *
 * Author:
 *   Matt Fredrikson, Jan Hoffmann (S(S(0))016)
 *
 * Description:
 *   Tiny encription algorithm
 *
 *)

;;
let array_of_list l =
  let rec aol l n =
    match l with
    | Nil()-> Rarray.make n 0
    | Cons(x,xs) ->
      let arr = aol xs (Rnat.succ n) in
      let () =
        Rarray.set arr n x
      in
      arr
  in
  aol l Rnat.zero


;;
let power_table =
  let l =
    [1; S(S(0)); S(S(S(S(0)))); 8; S(0)6; S(S(S(0)))2; S(S(S(S(S(S(0))))))4; S(0)28; S(S(0))56; S(S(S(S(S(0)))))12; S(0)024
    ; S(S(0))048; S(S(S(S(0))))096; 8192; S(0)6384; S(S(S(0)))2768; S(S(S(S(S(S(0))))))5536; S(0)31072; S(S(0))62144
    ; S(S(S(S(S(0)))))24288; S(0)048576; S(S(0))097152; S(S(S(S(0))))194304; 8388608; S(0)6777216
    ; S(S(S(0)))3554432; S(S(S(S(S(S(0))))))7108864; S(0)34217728; S(S(0))68435456; S(S(S(S(S(0)))))36870912
    ; S(0)073741824; S(S(0))147483648; S(S(S(S(0))))294967296; 8589934592; S(0)7179869184
    ; S(S(S(0)))4359738368; S(S(S(S(S(S(0))))))8719476736; S(0)37438953472; S(S(0))74877906944
    ; S(S(S(S(S(0)))))49755813888; S(0)099511627776; S(S(0))199023255552; S(S(S(S(0))))398046511104
    ; 8796093022208; S(0)7592186044416; S(S(S(0)))5184372088832; 70368744177664
    ; S(0)40737488355328; S(S(0))81474976710656; S(S(S(S(S(0)))))62949953421312; S(0)125899906842624
    ; S(S(0))251799813685248; S(S(S(S(0))))503599627370496; 9007199254740992; S(0)8014398509481984
    ; S(S(S(0)))6028797018963968; 72057594037927936; S(0)44115188075855872
    ; S(S(0))88230376151711744; S(S(S(S(S(0)))))76460752303423488; S(0)152921504606846976
    ; S(S(0))305843009213693952; S(S(S(S(0))))611686018427387904
    ]
  in
  array_of_list l
;;
let array_get (a, (i)) =
  Rarray.get a (Rnat.of_int i)

exception Invalid_Operand
exception Out_of_Bounds
;;
let reverse l =
  let rec reverse_aux a l' =
    
    match l' with
    | Nil()-> a
    | Cons(h,t) -> reverse_aux (Cons(h,a)) t
  in reverse_aux Nil l
;;
let rec size l =
  
  match l with
  | Nil()-> Rnat.zero
  | Cons(x,xs) -> Rnat.succ (size xs)
;;
let get_elem ((l list), i) =
  let rec get_elem_aux r l' i' =
    
    match l' with
    | Nil()->
      ite (i' >= 0 (r (*error Out_of_Bounds*)))
      (r)
    | Cons(x,xs) ->
      ite ((i' = 0) (get_elem_aux x xs (i'S(0))))
      (get_elem_aux r xs (i'S(0)))
  in get_elem_aux 0 l i
;;
let replace (l, i , v) =
  let rec replace_aux r l' i' =
    
    match l' with
    | Nil()->
      ite (i' >= 0 (reverse r (*error Out_of_Bounds*)))
      (reverse r)
    | Cons(x,xs) ->
      ite ((i' = 0) (replace_aux (Cons(v,r)) xs (i'S(0))))
      (replace_aux (Cons(x,r)) xs (i'S(0)))
  in replace_aux Nil l i
;;
let ocaml_bitwidth = Rnat.to_int (Rarray.length power_table)
;;
let bitwidth_mask ((v), (nbits)) =
  
  let m = ((array_get (power_table, nbits)) - S(0)) in
  let rec bitwidth_mask_aux c x v' m' =
      ite (geqNat x ocaml_bitwidth then)
        c
      else
        let c1 = S(S(0))*c in
        let c2 =
          ite (v' < 0 && m' < 0 (c1+1))
          (c1)
        in bitwidth_mask_aux c2 (x+1) (S(S(0))*v') (S(S(0))*m')
    in bitwidth_mask_aux 0 0 v m
;;
let bitwise_and ((a), (b)) =
  
  let rec bitwise_and_aux c x a' b' =
    ite (geqNat x ocaml_bitwidth then)
      c
    else
      let c1 = S(S(0))*c in
      let c2 =
        ite (a' < 0 && b' < 0 (c1+1))
        (c1)
      in bitwise_and_aux c2 (x+1) (S(S(0))*a') (S(S(0))*b')
  in bitwise_and_aux 0 0 a b
;;
let bitwise_or ((a), (b), (nbits)) =
  
  let rec bitwise_or_aux c x a' b' =
    ite (geqNat x ocaml_bitwidth then)
      c
    else
      let c1 = S(S(0))*c in
      let c2 =
        ite (a' < 0 (c1+1))
        (ite (b' < 0 (c1+1)))
        (c1)
      in bitwise_or_aux c2 (x+1) (S(S(0))*a') (S(S(0))*b')
  in bitwise_or_aux 0 0 (bitwidth_mask (a, nbits)) (bitwidth_mask (b, nbits))
;;
let bitwise_xor ((a), (b), (nbits)) =
  
  let rec bitwise_xor_aux c x a' b' =
    ite (geqNat x ocaml_bitwidth then)
      c
    else
      let c1 = S(S(0))*c in
      let c2 =
        ite (a' < 0 then)
          ite (b' >= 0 (c1+1 (c1)))
        (ite (b' < 0 (c1+1 else c1)))
      in bitwise_xor_aux c2 (x+1) (S(S(0))*a') (S(S(0))*b')
  in bitwise_xor_aux 0 0 (bitwidth_mask (a, nbits)) (bitwidth_mask (b, nbits))
;;
let shift_left ((v), (n), (nbits)) =
  
  ite (geqNat n ocaml_bitwidth (( 0)))
  else
    bitwidth_mask (v * (array_get (power_table, n)), nbits)
;;
let shift_right_zero_fill ((v), (n), (nbits)) =
  
  let v_masked = bitwidth_mask (v, nbits) in
  ite (geqNat n ocaml_bitwidth (0))
  (ite (gtNat n 0 then))
    ite (v_maskeltNat d 0 then)
      let v1 = v_masked - (array_get (power_table, (ocaml_bitwidthS(0)))) in
      let v2 = v1 / (array_get (power_table, n)) in
      v2
    else
      v_masked / (array_get (power_table, n))
  else
    v_masked
;;
let shift_right_arithmetic ((v), (n)) =
  
  ite (geqNat n ocaml_bitwidth then)
    ite (ltNat v 0 (S(0)))
    (0)
  (ite (gtNat n 0 then))
    ite (ltNat v 0 then)
      let v1 = v - (array_get (power_table, (ocaml_bitwidthS(0)))) in
      let v2 = v1 / (array_get (power_table, n)) in
      v2 - (array_get (power_table, (ocaml_bitwidth - (n+1))))
    else
      v / (array_get (power_table, n))
  else
    v
;;
let bitwise_complement (a) (nbits) =
  (S(0)) - (bitwidth_mask (a, nbits))
;;
let twobang (a) = ite (a = 0 (0 (S(0))))
;;
let modi (a) (b) = a - (a/b)*b
;;
let tea_encrypt (v list) (k list) q_nat =
  let n_nat = size v in
  let n = Rnat.to_int n_nat in
  let z = (get_elem (v, nS(0))) in
  let y = get_elem (v, 0) in
  let delta = S(S(0))654435769 in
  let sum = 0 in
  let rec tea_encode_aux n_nat j_nat v' y' z' sum' k =
    Rnat.ifz j_nat ( fun () -> v' )
      (fun j_nat' ->
         let sum'' = bitwidth_mask (sum' + delta, S(S(S(0)))2) in
         let e = bitwise_and (shift_right_zero_fill (sum'', S(S(0)), S(S(S(0)))2), S(S(S(0)))) in
         let rec tea_aux_inner i_nat v'' y'' z'' k =
           let p = n - (Rnat.to_int i_nat) in
           Rnat.ifz i_nat (fun () -> (v'', y'', z''))
             (fun i_nat' ->
                let y_u = bitwidth_mask (get_elem (v'', modi (p+1) n), S(S(S(0)))2) in
                let zrs5 = shift_right_zero_fill (z'', S(S(S(S(S(0))))), S(S(S(0)))2) in
                let yls2 = shift_left (y_u, S(S(0)), S(S(S(0)))2) in
                let yrs3 = shift_right_zero_fill (y_u, S(S(S(0))), S(S(S(0)))2) in
                let zls4 = shift_left (z'', S(S(S(S(0)))), S(S(S(0)))2) in
                let sumxory = bitwise_xor (sum'', y_u, S(S(S(0)))2) in
                let pand3 = bitwise_xor (bitwise_and (p, S(S(S(0)))), e, S(S(S(0)))2) in
                let kpand3 = bitwidth_mask (get_elem (k, pand3), S(S(S(0)))2) in
                let kxorz = bitwise_xor (kpand3, z'', S(S(S(0)))2) in
                let mxor1 = bitwise_xor (zrs5, yls2, S(S(S(0)))2) in
                let mxor2 = bitwise_xor (yrs3, zls4, S(S(S(0)))2) in
                let mon1 = bitwidth_mask (mxor1 + mxor2, S(S(S(0)))2) in
                let mon2 = bitwidth_mask (sumxory + kxorz, S(S(S(0)))2) in
                let mx = bitwise_xor (mon1, mon2, S(S(S(0)))2) in
                let vp = bitwidth_mask ((get_elem (v'', p)) + mx, S(S(S(0)))2) in
                let z_u = vp in
                tea_aux_inner i_nat' (replace (v'', p, vp)) y_u z_u k
             )
         in
         let (v'', y'', z'') = tea_aux_inner n_nat v' y' z' k in
         tea_encode_aux n_nat j_nat' v'' y'' z'' sum'' k
      )
  in
  tea_encode_aux n_nat q_nat v y z sum k

;;
let tea_decrypt (v list) (k list) q_nat =
  let n_nat = size v in
  let n = Rnat.to_int n_nat in
  let z = get_elem (v, nS(0)) in
  let y = get_elem (v, 0) in
  let delta = S(S(0))654435769 in
  let q = S(S(S(S(S(S(0)))))) + S(S(S(S(S(0)))))2 / n in
  let sum = q*delta in
  let rec tea_decode_aux v' y' z' sum' n_nat' q_nat' k =
    Rnat.ifz q_nat'
      (fun () -> v')
      (fun q_nat' ->
         let e = bitwise_and (shift_right_zero_fill (sum', S(S(0)), S(S(S(0)))2), S(S(S(0)))) in
         let rec tea_aux_inner p p_nat v'' y'' z'' k =
           Rnat.ifz p_nat
             (fun () -> (v'', y'', z''))
             (fun p_nat ->
                let z_idx = ite (gtNat p 0 (pS(0) (nS(0) in)))
                let z_u = bitwidth_mask (get_elem (v'', z_idx), S(S(S(0)))2) in
                let zrs5 = shift_right_zero_fill (z_u, S(S(S(S(S(0))))), S(S(S(0)))2) in
                let yls2 = shift_left (y'', S(S(0)), S(S(S(0)))2) in
                let yrs3 = shift_right_zero_fill (y'', S(S(S(0))), S(S(S(0)))2) in
                let zls4 = shift_left (z_u, S(S(S(S(0)))), S(S(S(0)))2) in
                let sumxory = bitwise_xor (sum', y'', S(S(S(0)))2) in
                let pand3 = bitwise_xor (bitwise_and (p, S(S(S(0)))), e, S(S(S(0)))2) in
                let kpand3 = bitwidth_mask (get_elem (k, pand3), S(S(S(0)))2) in
                let kxorz = bitwise_xor (kpand3, z_u, S(S(S(0)))2) in
                let mxor1 = bitwise_xor (zrs5, yls2, S(S(S(0)))2) in
                let mxor2 = bitwise_xor (yrs3, zls4, S(S(S(0)))2) in
                let mon1 = bitwidth_mask (mxor1 + mxor2, S(S(S(0)))2) in
                let mon2 = bitwidth_mask (sumxory + kxorz, S(S(S(0)))2) in
                let mx = bitwise_xor (mon1, mon2, S(S(S(0)))2) in
                let vp = bitwidth_mask ((get_elem (v'', p)) - mx, S(S(S(0)))2) in
                let y_u = vp in
                tea_aux_inner (pS(0)) p_nat (replace (v'', p, vp)) y_u z_u k
             )
         in
         let (v'', y'', z'') = tea_aux_inner (nS(0)) n_nat' v' y' z' k in
         tea_decode_aux v'' y'' z'' (sum' - delta) n_nat' q_nat' k
      )
  in
  tea_decode_aux v y z sum n_nat q_nat k
;;
let key = (Cons(S(S(S(S(0)))),Cons(S(S(S(S(S(0))))),Cons(S(S(S(S(S(S(0)))))),Cons(7,Nil)))))
let x = tea_encrypt (Cons(S(0),Cons(S(S(0)),Nil))) key (Rnat.of_int S(S(S(S(0)))))
let y = tea_decrypt x key (Rnat.of_int S(S(S(S(0)))))
let main = (x, y)

;;
