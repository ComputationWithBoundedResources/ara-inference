type 'a option = None | Some of 'a
;;
type ('a,'b) pair = Pair of 'a * 'b
;;
type 'a list = Nil | Cons of 'a * 'a list
;;
type Unit = Unit

(* * * * * * * * * * *
 * Resource Aware ML *
 * * * * * * * * * * *
 *
 * * *  Use Cases  * *
 *
 * File:
 *   examples/constant_time/xxtea.raml
 *
 * Author:
 *   Matt Fredrikson, Jan Hoffmann (2016)
 *
 * Description:
 *   Tiny encription algorithm
 *
 *)

;;
let array_of_list (l : int list) =
  let rec aol l n =
    match l with
    | Nil -> Rarray.make n 0
    | Cons(x,xs) ->
      let arr = aol xs (Rnat.succ n) in
      let () =
        Rarray.set arr n x
      in
      arr
  in
  aol l Rnat.zero


;;
let power_table =
  let l =
    [1; 2; 4; 8; 16; 32; 64; 128; 256; 512; 1024
    ; 2048; 4096; 8192; 16384; 32768; 65536; 131072; 262144
    ; 524288; 1048576; 2097152; 4194304; 8388608; 16777216
    ; 33554432; 67108864; 134217728; 268435456; 536870912
    ; 1073741824; 2147483648; 4294967296; 8589934592; 17179869184
    ; 34359738368; 68719476736; 137438953472; 274877906944
    ; 549755813888; 1099511627776; 2199023255552; 4398046511104
    ; 8796093022208; 17592186044416; 35184372088832; 70368744177664
    ; 140737488355328; 281474976710656; 562949953421312; 1125899906842624
    ; 2251799813685248; 4503599627370496; 9007199254740992; 18014398509481984
    ; 36028797018963968; 72057594037927936; 144115188075855872
    ; 288230376151711744; 576460752303423488; 1152921504606846976
    ; 2305843009213693952; -4611686018427387904
    ]
  in
  array_of_list l
;;
let array_get Pair((a : int Rarray.t), i) =
  Rarray.get a (Rnat.of_int i)

exception Invalid_Operand
exception Out_of_Bounds
;;
let reverse (l : int list) =
  let rec reverse_aux a l' =
    Raml.tick(32.0);
    match l' with
    | Nil -> a
    | Cons(h,t) -> reverse_aux (Cons(h,a)) t
  in reverse_aux Nil l
;;
let rec size (l : int list) =
  Raml.tick(32.0);
  match l with
  | Nil -> Rnat.zero
  | Cons(x,xs) -> Rnat.succ (size xs)
;;
let get_elem(l, i) =
  let rec get_elem_aux r l' i' =
    Raml.tick(32.0);
    match l' with
    | Nil ->
      if i' >= 0 then r (*raise Out_of_Bounds*)
      else r
    | Cons(x,xs) ->
      if (i' = 0) then get_elem_aux x xs (i'-1)
      else get_elem_aux r xs (i'-1)
  in get_elem_aux 0 l i
;;
let replace ((l : int list), i , v) =
  let rec replace_aux r l' i' =
    Raml.tick(32.0);
    match l' with
    | Nil ->
      if i' >= 0 then reverse r (*raise Out_of_Bounds*)
      else reverse r
    | Cons(x,xs) ->
      if (i' = 0) then replace_aux (Cons(v,r)) xs (i'-1)
      else replace_aux (Cons(x,r)) xs (i'-1)
  in replace_aux Nil l i
;;
let ocaml_bitwidth = Rnat.to_int (Rarray.length power_table)
;;
let bitwidth_mask(v, nbits) =
  Raml.tick 32.0;
  let m = ((array_get Pair(power_table, nbits)) - 1) in
  let rec bitwidth_mask_aux c x v' m' =
      if x >= ocaml_bitwidth then
        c
      else
        let c1 = 2*c in
        let c2 =
          if v' < 0 && m' < 0 then c1+1
          else c1
        in bitwidth_mask_aux c2 (x+1) (2*v') (2*m')
    in bitwidth_mask_aux 0 0 v m
;;
let bitwise_and(a, b) =
  Raml.tick(32.0);
  let rec bitwise_and_aux c x a' b' =
    if x >= ocaml_bitwidth then
      c
    else
      let c1 = 2*c in
      let c2 =
        if a' < 0 && b' < 0 then c1+1
        else c1
      in bitwise_and_aux c2 (x+1) (2*a') (2*b')
  in bitwise_and_aux 0 0 a b
;;
let bitwise_or (a, b, nbits) =
  Raml.tick(32.0);
  let rec bitwise_or_aux c x a' b' =
    if x >= ocaml_bitwidth then
      c
    else
      let c1 = 2*c in
      let c2 =
        if a' < 0 then c1+1
        else if b' < 0 then c1+1
        else c1
      in bitwise_or_aux c2 (x+1) (2*a') (2*b')
  in bitwise_or_aux 0 0 (bitwidth_mask(a, nbits)) (bitwidth_mask(b, nbits))
;;
let bitwise_xor (a, b, nbits) =
  Raml.tick(32.0);
  let rec bitwise_xor_aux c x a' b' =
    if x >= ocaml_bitwidth then
      c
    else
      let c1 = 2*c in
      let c2 =
        if a' < 0 then
          if b' >= 0 then c1+1 else c1
        else if b' < 0 then c1+1 else c1
      in bitwise_xor_aux c2 (x+1) (2*a') (2*b')
  in bitwise_xor_aux 0 0 (bitwidth_mask(a, nbits)) (bitwidth_mask(b, nbits))
;;
let shift_left (v, n, nbits) =
  Raml.tick(32.0);
  if n >= ocaml_bitwidth then (Raml.tick 32.0; 0)
  else
    bitwidth_mask (v * (array_get Pair(power_table, n)), nbits)
;;
let shift_right_zero_fill (v, n, nbits) =
  Raml.tick(32.0);
  let v_masked = bitwidth_mask(v, nbits) in
  if n >= ocaml_bitwidth then 0
  else if n > 0 then
    if v_masked < 0 then
      let v1 = v_masked - (array_get (power_table, (ocaml_bitwidth-1))) in
      let v2 = v1 / (array_get Pair(power_table, n)) in
      v2
    else
      v_masked / (array_get Pair(power_table, n))
  else
    v_masked
;;
let shift_right_arithmetic(v, n) =
  Raml.tick(32.0);
  if n >= ocaml_bitwidth then
    if v < 0 then -1
    else 0
  else if n > 0 then
    if v < 0 then
      let v1 = v - (array_get (power_table, (ocaml_bitwidth-1))) in
      let v2 = v1 / (array_get Pair(power_table, n)) in
      v2 - (array_get (power_table, (ocaml_bitwidth - (n+1))))
    else
      v / (array_get Pair(power_table, n))
  else
    v
;;
let bitwise_complement a nbits =
  (-1) - (bitwidth_mask(a, nbits))
;;
let twobang (a:int) = if a = 0 then 0 else 1
;;
let modi (a:int) (b:int) = a - (a/b)*b
;;
let tea_encrypt v k q_nat =
  let n_nat = size v in
  let n = Rnat.to_int n_nat in
  let z = (get_elem Pair(v, n-1)) in
  let y = get_elem(v, 0) in
  let delta = 2654435769 in
  let sum = 0 in
  let rec tea_encode_aux n_nat j_nat v' y' z' sum' k =
    Rnat.ifz j_nat ( fun () -> v' )
      (fun j_nat' ->
         let sum'' = bitwidth_mask Pair(sum' + delta, 32) in
         let e = bitwise_and (shift_right_zero_fill (sum'', 2, 32), 3) in
         let rec tea_aux_inner i_nat v'' y'' z'' k =
           let p = n - (Rnat.to_int i_nat) in
           Rnat.ifz i_nat (fun () -> (v'', y'', z''))
             (fun i_nat' ->
                let y_u = bitwidth_mask (get_elem (v'', modi (p+1) n), 32) in
                let zrs5 = shift_right_zero_fill (z'', 5, 32) in
                let yls2 = shift_left (y_u, 2, 32) in
                let yrs3 = shift_right_zero_fill (y_u, 3, 32) in
                let zls4 = shift_left (z'', 4, 32) in
                let sumxory = bitwise_xor (sum'', y_u, 32) in
                let pand3 = bitwise_xor (bitwise_and(p, 3), e, 32) in
                let kpand3 = bitwidth_mask (get_elem(k, pand3), 32) in
                let kxorz = bitwise_xor (kpand3, z'', 32) in
                let mxor1 = bitwise_xor (zrs5, yls2, 32) in
                let mxor2 = bitwise_xor (yrs3, zls4, 32) in
                let mon1 = bitwidth_mask Pair(mxor1 + mxor2, 32) in
                let mon2 = bitwidth_mask Pair(sumxory + kxorz, 32) in
                let mx = bitwise_xor (mon1, mon2, 32) in
                let vp = bitwidth_mask ((get_elem(v'', p)) + mx, 32) in
                let z_u = vp in
                tea_aux_inner i_nat' (replace (v'', p, vp)) y_u z_u k
             )
         in
         let (v'', y'', z'') = tea_aux_inner n_nat v' y' z' k in
         tea_encode_aux n_nat j_nat' v'' y'' z'' sum'' k
      )
  in
  tea_encode_aux n_nat q_nat v y z sum k

;;
let tea_decrypt v k q_nat =
  let n_nat = size v in
  let n = Rnat.to_int n_nat in
  let z = get_elem Pair(v, n-1) in
  let y = get_elem(v, 0) in
  let delta = 2654435769 in
  let q = 6 + 52 / n in
  let sum = q*delta in
  let rec tea_decode_aux v' y' z' sum' n_nat' q_nat' k =
    Rnat.ifz q_nat'
      (fun () -> v')
      (fun q_nat' ->
         let e = bitwise_and (shift_right_zero_fill (sum', 2, 32), 3) in
         let rec tea_aux_inner p p_nat v'' y'' z'' k =
           Rnat.ifz p_nat
             (fun () -> (v'', y'', z''))
             (fun p_nat ->
                let z_idx = if p > 0 then p-1 else n-1 in
                let z_u = bitwidth_mask (get_elem Pair(v'', z_idx), 32) in
                let zrs5 = shift_right_zero_fill (z_u, 5, 32) in
                let yls2 = shift_left (y'', 2, 32) in
                let yrs3 = shift_right_zero_fill (y'', 3, 32) in
                let zls4 = shift_left (z_u, 4, 32) in
                let sumxory = bitwise_xor (sum', y'', 32) in
                let pand3 = bitwise_xor (bitwise_and(p, 3), e, 32) in
                let kpand3 = bitwidth_mask (get_elem(k, pand3), 32) in
                let kxorz = bitwise_xor (kpand3, z_u, 32) in
                let mxor1 = bitwise_xor (zrs5, yls2, 32) in
                let mxor2 = bitwise_xor (yrs3, zls4, 32) in
                let mon1 = bitwidth_mask Pair(mxor1 + mxor2, 32) in
                let mon2 = bitwidth_mask Pair(sumxory + kxorz, 32) in
                let mx = bitwise_xor (mon1, mon2, 32) in
                let vp = bitwidth_mask ((get_elem(v'', p)) - mx, 32) in
                let y_u = vp in
                tea_aux_inner (p-1) p_nat (replace (v'', p, vp)) y_u z_u k
             )
         in
         let (v'', y'', z'') = tea_aux_inner (n-1) n_nat' v' y' z' k in
         tea_decode_aux v'' y'' z'' (sum' - delta) n_nat' q_nat' k
      )
  in
  tea_decode_aux v y z sum n_nat q_nat k
;;
let key = [4;5;6;7]
let x = tea_encrypt [1;2] key (Rnat.of_int 4)
let y = tea_decrypt x key (Rnat.of_int 4)
let unused = Pair(x, y)









;;
