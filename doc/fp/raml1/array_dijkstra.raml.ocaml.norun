
let rec leqNat x y =
  match y with
  | 0 -> True
  | S(y') -> (match x with
            | S(x') -> leqNat x' y'
            | 0 -> False)
;;
let rec eqNat x y =
  match y with
  | 0 -> (match x with
      | 0 -> True
      | S(x') -> False)
  | S(y') -> (match x with
            | S(x') -> eqNat x' y'
            | 0 -> False)
;;
let rec geqNat x y =
  match x with
   | 0 -> False
   | S(x') -> (match y with
              | 0 -> True
              | S(y') -> geqNat x' y')
;;
let rec ltNat x y =
  match y with
   | 0 -> False
   | S(y') -> (match x with
        | 0 -> True
        | S(x') -> ltNat x' y')
;;
let rec gtNat x y =
  match x with
   | 0 -> False
   | S(x') -> (match y with
             | 0 -> True
             | S(y') -> gtNat x' y')


;;
let ifz n th el = match n with
   | 0 -> th 0
   | S(x) -> el x
;;
let ite b th el = match b with
   | True()-> th
   | False()-> el
;;
let minus n m =
  let rec minus' m n = match m with
        | 0 -> 0
        | S(x) -> (match n with
          | 0 -> m
          | S(y) -> minus' x y)
  in Pair(minus' n m,m)
;;
let rec plus n m = match m with
  | 0 -> n
  | S(x) -> S(plus n x)
;;
type ('a,'b,'c) triple = Triple of 'a * 'b * 'c
;;
let rec div_mod n m = match (minus n m) with
  | Pair(res,m) -> (match res with
                   | 0 -> Triple (0,n,m)
                   | S(x) -> (match (div_mod res m) with
                             | Triple(a,rest,unusedM) -> Triple(plus S(0) a,rest,m)))
;;
let rec mult n m = match n with
   | 0 -> 0
   | S(x) -> S(plus (mult x m) m)
;;
type bool = True | False
;;
type 'a option = None | Some of 'a
;;
type 'a list = Nil | Cons of 'a * 'a list
;;
type Unit = Unit
;;
type ('a,'b) pair = Pair of 'a * 'b

(* * * * * * * * * * *
 * Resource Aware ML *
 * * * * * * * * * * *
 * File:
 *   examples/raml1/array_dijkstra.raml
 *
 * Author:
 *   Jan Hoffmann (S(S(0))015)
 *
 * Resource Bound:
 *   O(n^2)
 *
 * Description:
 *   Dijkstra's algorithm for the single-source shortest-path problem of a weighted,
 *   undirected graph.  Edges are required to have non-negative weights.  For more
 *   info see http://en.wikipedia.org/wiki/Dijkstra's_algorithm.
 *)

(* Get and set the weight of an edge in a graph. *)
(* The weight S(0) indicates that the edge does not exist.*)
;;
let getWeight g v u =
  Rarray.get (Rarray.get g v) u

;;
let setWeight g v u d =
  let unused = Rarray.set (Rarray.get g v) u d in
  Rarray.set (Rarray.get g u) v d


exception Invalid_argument

(* Compute the node v in the queue l with minimal distance in
   the array dist and remove v from l.*)

(*makeGraph(n,l) creates a graph with n nodes 0,...,nS(0) and edges as
  given in the list l. *)
;;
let rec fillGraph l g =
  match l with
  | Nil()-> ()
  | Cons(e,es) ->
     let (u,v,d) = e in
     let unused = setWeight g u v d in
     fillGraph es g
;;
let rec fillEmpty n size g =
  Rnat.ifz n
    (fun () -> ())
    begin fun n' ->
      let a = Rarray.make size (S(0)) in
      let unused = Rarray.set g n' a in
      fillEmpty n' size g
    end
;;
let emptyGraph n =
  let dummy = Rarray.make Rnat.zero (S(0)) in
  let g = Rarray.make n dummy in
  let unused = fillEmpty n n g in
  g
;;
let makeGraph n l =
  let g = emptyGraph n in
  let unused = fillGraph l g in g

;;
let rec getMin l dist =
  match l with
  | Nil()-> error Invalid_argument
  | Cons(v,vs) ->
     match vs with
     | Nil()-> (Nil,v,Rarray.get dist v)
     | Cons(y,ys) ->
        let (l',u,d_u) = getMin vs dist in
        let d_v = Rarray.get dist v in
        ite ((d_v < d_u && d_v > S(0)) || d_u = S(0) then)
          (Cons(u,l'),v,d_v)
        else
          (Cons(v,l'),u,d_u)


(* Create a queue with all nodes. *)
;;
let rec startQueue n =
  Rnat.ifz n
   (fun () -> Nil)
   (fun n -> Cons(n,(startQueue n)))
;;
let rec updateNeighbors n v g dist prev =
  Rnat.ifz n
   (fun () -> () )
   begin fun n' ->
     let (u,d_u) = (n', Rarray.get dist n') in
     let d_u_v = (Rarray.get dist v) + (getWeight g v u) in
     let unused = updateNeighbors n' v g dist prev in
     ite ((getWeight g v u) > (S(0)) && (d_u > d_u_v || d_u = S(0) ) then)
        let unused = Rarray.set dist u d_u_v in
        Rarray.set prev u v
      else
        ()
   end
;;
let rec processNodes queue g dist prev =
  match queue with
  | Nil()-> ()
  | _::_q ->
     let (queue',v,d_v) = getMin queue dist in
     ite (d_v = S(0) then)
       ()
     else
       let unused = updateNeighbors (Rarray.length g) v g dist prev in
       processNodes queue' g dist prev

;;
let dijkstra g source =
  let n = Rarray.length g in
  let dist = Rarray.make n (S(0)) in
  let prev = Rarray.make n Rnat.zero in
  let unused = Rarray.set dist source 0 in
  let queue = startQueue n in
  let unused = processNodes queue g dist prev in
  dist

;;
let arr_of_list l seed =
  let rec a_of_l l n =
    match l with
    | Nil()-> Rarray.make n seed
    | Cons(x,xs) -> let arr = a_of_l xs (Rnat.succ n) in
               let unused = Rarray.set arr n x in arr
  in
  a_of_l l Rnat.zero
;;
let main =
  let g = arr_of_list
  [ arr_of_list (Cons(S(0),Cons(  S(0),Cons( S(0)000,Cons( S(0)000,Cons( S(0)000,Cons( S(0)000,Nil))))))) 0
  ; arr_of_list (Cons(S(0),Cons( S(0),Cons(    S(0),Cons( 900,Cons( 900,Cons( 900,Nil))))))) 0
  ; arr_of_list (Cons(S(0),Cons( S(0),Cons(   S(0),Cons(    S(0),Cons( 800,Cons( 800,Nil))))))) 0
  ; arr_of_list (Cons(S(0),Cons( S(0),Cons(   S(0),Cons(   S(0),Cons(    S(0),Cons( 700,Nil))))))) 0
  ; arr_of_list (Cons(S(0),Cons( S(0),Cons(   S(0),Cons(   S(0),Cons(   S(0),Cons(    S(0),Nil))))))) 0
  ; arr_of_list (Cons(S(0),Cons( S(0),Cons(   S(0),Cons(   S(0),Cons(   S(0),Cons(   S(0),Nil))))))) 0
  ]
  (Rarray.make Rnat.zero 0)
  in dijkstra g Rnat.zero

;;
